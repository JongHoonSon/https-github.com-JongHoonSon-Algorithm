function solution(sizes) {
  var answer = 0;

  // 모든 명함의 사이즈를 가로 길이, 세로 길이 중
  // 간 것을 0번 인덱스에, 짧은 것을 1번 인덱스에 오도록 설정함

  // (가로 길이가 더 큰 명함 ex) 8x4 크기의 명함 => 그대로 사용)
  // (세로 길이가 더 큰 명함 ex) 5x10 크기의 명함 => 가로로 눕혀서 10x5가 되게 함)
  for (let i = 0; i < sizes.length; i++) {
    sizes[i].sort((a, b) => b - a);
  }

  let maxWidth = 0;
  let maxHeight = 0;

  for (let i = 0; i < sizes.length; i++) {
    // 가로 길이가 가장 큰 명함을 찾음
    // (0번 인덱스는 명함을 똑바로 놓거나, 가로로 눕혔을 때의 가로 길이)
    if (maxWidth < sizes[i][0]) {
      maxWidth = sizes[i][0];
    }

    // 세로 길이가 가장 큰 명함을 찾음
    // (1번 인덱스는 명함을 똑바로 놓거나, 가로로 눕혔을 때의 세로 길이)
    if (maxHeight < sizes[i][1]) {
      maxHeight = sizes[i][1];
    }
  }

  // 명함 중에서 가로 길이가 가장 큰 명함의 가로 길이와
  // 명함 중에서 세로 길이가 가장 큰 명함의 세로 길이를 곱하면
  // 문제에서 요구하는 명함지갑의 최소 크기가 나온다.
  answer = maxWidth * maxHeight;

  return answer;
}

// 후기

// 1레벨 문제임에도 불구하고 처음 시도한 문제 풀이 접근 방식이 좋지 않았다.
// 일단 주어진 직사각형 중에 최대 가로 길이와 최대 세로 길이를 구한 다음,
// 최대 세로 길이의 직사각형의 인덱스를 기억해서,
// 해당 직사각형의 가로길이와 세로길이를 변경한 후(명함을 가로로 눕힘)
// 다시 한번 최대 가로 길이와 최대 세로 길이를 구해서
// 그 둘의 곱이 줄어들면 명함을 가로로 눕히는 행위를 진행했다.

// 이렇게 구현하니 몇몇 문제는 테케 약 15개 중에서 2~3개는 풀렸지만
// 나머지 문제는 풀리지 않았고, 접근 방식 자체가 아예 잘못됐다는 것을 알게되었다.

// 문제 풀이 접근 방식

// 후기에서 적은 이유 때문에 구글링을 하여 문제푸는 방식을 찾았는데
// 알고보니 각 명함의 가로 길이, 세로 길이 중에서
// 작은 값을 0번 인덱스로, 큰 값을 1번 인덱스로 변경한 뒤

// 모든 명함에 대해 반복하면서 0번 인덱스 중 가장 큰 값, 1번 인덱스 중 가장 큰 값을
// 명함 지갑의 사이즈로 설정하면 되는 것이었다.

// 단순하게 생각하면 된 것을 어렵게 접근한 것 같아 아쉽다.
