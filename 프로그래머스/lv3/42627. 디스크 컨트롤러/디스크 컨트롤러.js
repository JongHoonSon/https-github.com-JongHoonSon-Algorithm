function solution(jobs) {
  var answer = 0;

  // 먼저 작업을 요청시간대로 정렬함
  // (요청시간이 낮은 순으로 정렬(=빨리 요청되는 것부터))
  jobs.sort((a, b) => a[0] - b[0]);

  // j는 jobs의 index (0부터 시작)
  let j = 0;

  // 요청되는 작업들을 처리하는 과정에서 변경되는 시간을 저장할 변수
  // (여기서 시간은 특정 시점마다 변경된다. (다음 작업이 시작될 때, 다음 작업이 끝날 때 등))

  // 먼저 time을 가장 요청시간이 빠른 작업의 시작 시점으로 함
  let time = jobs[0][0];

  // 현재까지 수행한 작업들의 대기시간 + 수행시간의 합
  let totalTime = 0;

  // 특정 작업을 수행 중일 때 요청된 작업들을 받아서
  // 수행시간이 짧은 순서대로 정렬하는 우선순위 큐
  let priorityQueue = [];

  // jobs에 들어있는 모든 작업을 돌지 못했거나
  // 우선 순위 큐에 작업이 들어있으면
  // 반복
  while (j < jobs.length || priorityQueue.length !== 0) {
    // (여기서 time은 지금 수행 중인 작업이 종료되는 시점의 시간)
    // 현재 진행 중인 작업이 종료되기 이전에
    // 새로 요청되는 작업이 있으면
    // => 1. 해당 작업을 우선 순위 큐에 넣는 작업 수행
    if (jobs.length > j && time >= jobs[j][0]) {
      // 우선 순위 큐에 j번 index의 작업을 추가
      priorityQueue.push(jobs[j++]);

      // 우선 순위 큐를 작업들의 소요시간에 따라 정렬
      // (소요시간이 낮은 순으로 정렬)
      priorityQueue.sort((a, b) => a[1] - b[1]);

      // 다음 작업을 처리하기 위해 이동
      continue;
    }

    // 현재 진행 중인 작업이 종료되기 이전에
    // 새로 요청되는 작업이 없으면 (= 위의 조건문에 안걸렸다면)
    // => 2. 다음 작업을 우선 순위 큐에서 꺼내는 과정 수행

    // 2-1. 우선 순위 큐가 비어있지 않다면
    // (= 다음에 수행해야될 것이 있으면)
    if (priorityQueue.length !== 0) {
      // time은 지금 수행 중인 작업이 종료되는 시점의 시간,
      // time에 우선 순위 큐에 있는 다음 작업의 수행시간을 더하여
      // 다음 작업의 수행이 끝난 시점의 시간을 저장함
      // (다음 작업을 수행하기 위한 준비)
      time = time + priorityQueue[0][1];

      // totalTime에는 time에서 다음 작업의 요청시간을 뺀 값을 저장
      // 다음 작업이 끝나는 시점의 시간 - 다음 작업의 요청시간
      // (= 다음 작업의 대기시간 + 소요시간)
      totalTime = totalTime + (time - priorityQueue[0][0]);

      // 다음 작업을 우선 순위 큐에서 뺌
      priorityQueue.shift();

      // 2-2. 우선 순위 큐가 비어있다면
      // (= 작업 중인 것이 없는데, 새로운 작업이 아직 요청되지 않았다면)
      // (= 작업을 하다가 중간에 쉬고, 새로운 작업이 들어오는 경우)
    } else {
      // time을 다음에 들어오는 작업의 요청시간으로 설정함
      // (현재 시간을 요청시간으로 설정만 해놓았을 뿐, 아직 수행한 것은 아님,
      // 이후 2-1이 수행되는 과정에서 time값이 해당 작업의 종료시점으로 다시 변경될 것임)
      time = jobs[j][0];
    }
  }

  // 정답은 각 작업의 (대기시간+소요시간)을 작업의 수로 나눈 것
  // (문제 조건에 의해 소수점 이하의 수는 버림)
  answer = Math.floor(totalTime / jobs.length);

  return answer;
}

// 후기

// 문제의 분류가 힙으로 되어있어서, 힙이 무엇인지, 힙은 어떻게 만드는지,
// 힙 정렬은 어떤 방식으로 하는건지를 찾아보고 문제를 풀려고 하였다.
// 하지만 문제를 푸는 과정에서 힙과 관련된 내용은 1도 사용하지 않아도 되었고,
// 그저 js의 내장 함수인 sort로 정렬을 진행해도 무리없이 풀 수 있는 문제였다.

// 문제 풀이 접근 방식

// 이 문제의 핵심은 특정 시점마다 조건에 따라 수행해야 하는 것을 이해하는 것이다.

// 먼저 시점은 크게 2가지로 나눌 수 있다.

// 1. 특정 작업의 수행이 시작되는 시점
// 2. 특정 작업의 수행이 종료되는 시점

// 디스크 컨트롤러가 수행되는 과정은 다음과 같다.

// A. 첫 작업을 시작하기 이전
//    => 시점을 첫 작업의 요청시간으로 변경

// B. 작업 수행하기
//    => 시점을 다음 작업의 종료시간으로 변경

// C. 수행 중인 작업이 끝나기 전에 새로 들어오는 작업이 있는지 판단
//    => 있다면, 해당 작업을 우선 순위 큐에 넣음

//    => 없다면, 현재 대기 중인 작업이 있는지 확인
//               => 있다면, B로 감

//               => 없다면, 시점을 다음 작업이 시작되는 시점으로 변경하고 B로 감
