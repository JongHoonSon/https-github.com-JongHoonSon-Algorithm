function solution(jobs) {
  var answer = 0;

  // 먼저 작업을 요청시간대로 정렬함
  // (요청시간이 낮은 것(=빨리 요청되는 것)순으로 정렬)
  jobs.sort((a, b) => a[0] - b[0]);

  // j는 jobs의 index (0부터 시작)
  let j = 0;

  // 요청되는 작업들을 처리하는 과정에서 변경되는 시간을 저장할 변수
  // (여기서 시간은 특정 시점마다 변경된다. (다음 작업이 시작될 때, 다음 작업이 끝날 때 등))
  let time = 0;

  // 현재까지 수행한 작업들의 대기시간 + 수행시간의 합
  let totalTime = 0;

  // 특정 작업을 수행중일 때 요청된 작업들을 받아서
  // 수행시간이 짧은 순서대로 정렬하는 우선순위 큐
  let priorityQueue = [];

  // jobs에 들어있는 모든 작업을 돌지 못했거나
  // 우선순위 큐에 작업이 들어있으면
  // 반복
  while (j < jobs.length || priorityQueue.length !== 0) {
    // (여기서 time은 지금 수행중인 작업이 종료되는 시점의 시간)
    // 현재 진행 중인 작업이 종료되기 이전에
    // 새로 요청되는 작업이 있으면
    // => 1. 해당 작업을 우선순위 큐에 넣는 작업 수행
    if (jobs.length > j && time >= jobs[j][0]) {
      // 우선 순위 큐에 j번 index의 작업을 추가
      priorityQueue.push(jobs[j++]);

      // 우선 순위 큐를 작업들의 소요시간에 따라 정렬
      // (수행시간이 낮은 것순으로 정렬)
      priorityQueue.sort((a, b) => a[1] - b[1]);

      // 다음 작업을 처리하기 위해 이동
      continue;
    }

    // 현재 진행 중인 작업이 종료되기 이전에
    // 새로 요청되는 작업이 없으면 (= 위의 조건문에 안걸렸다면)
    // => 2. 다음 작업을 우선순위 큐에서 꺼내는 과정 수행

    // 2-1. 우선순위 큐가 비어있지 않다면
    // (= 다음에 수행해야될 것이 있으면)
    if (priorityQueue.length !== 0) {
      // time은 지금 수행중인 작업이 종료되는 시점의 시간,
      // time에 우선순위 큐에 있는 다음 작업의 수행시간을 더하여
      // 다음 작업을 수행할 준비를 함
      time = time + priorityQueue[0][1];

      // totalTime에는 time에서 다음 작업의 요청시간을 뺀 값을 저장
      // 다음 작업이 끝나는 시점의 시간 - 다음 작업의 요청시간
      // (= 다음 작업의 대기시간 + 소요시간)
      totalTime = totalTime + (time - priorityQueue[0][0]);

      // 다음 작업을 우선순위 큐에서 뺌
      priorityQueue.shift();

      // 2-2. 우선순위 큐가 비어있다면
      // (= 작업 중인 것이 없는데, 새로운 작업이 아직 요청되지 않았다면)
      // (= 작업을 하다가 중간에 쉬고, 새로운 작업이 들어온 경우거나)
      // (= 아예 첫 작업인 경우임)
    } else {
      // time을 다음에 들어오는 작업의 요청시간으로 설정함
      // (현재 시간을 요청시간으로 설정만 해놓았을 뿐, 아직 수행한 것은 아님,
      // 2-1에서 수행되는 과정에서 time값이 해당 작업의 종료시점으로 계산될 것임)
      time = jobs[j][0];
    }
  }

  // 정답은 각 작업의 (대기시간+소요시간)을 작업의 수로 나눈 것
  // (문제 조건에 의해 소수점 이하의 수는 버림)
  answer = Math.floor(totalTime / jobs.length);

  return answer;
}
