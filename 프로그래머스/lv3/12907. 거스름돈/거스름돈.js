function solution(n, money) {
  var answer = 0;

  // 1원부터 n원까지 거스름돈을 거슬러줄 때의 경우의 수
  let d = new Array(n + 1).fill(0);

  // 0원은 1로 초기화함
  // (각 화폐 단위 별로 처음에 d[i-money[i]]에서 1개를 받아오기 위함)
  d[0] = 1;

  // i는 각 화폐 단위
  for (let i = 0; i < money.length; i++) {
    // j는 거스름돈 (1원부터 n원까지)
    for (let j = 1; j <= n; j++) {
      // 만약 j원이 화폐의 값보다 크면
      // ex) 1000원은 화폐 단위 100원보다 크므로, 계산 o
      // ex) 99원은 화폐 단위 100원보다 크므로, 계산 x
      if (j >= money[i]) {
        d[j] = d[j] + d[j - money[i]];
      }
    }
  }

  answer = d[n];

  return answer;
}

// 후기

// DP를 이용해서 상향식으로 구현할 수 있는 문제인데,
// 너무 어렵게 생각한 나머지 문제도 제대로 읽지 않고 풀기 시작했다.
// 결국 1시간 동안 짠 코드가 잘 통과하지 않고 문제를 다시 읽는 과정에서
// 내가 문제를 완전히 잘못 이해한 것을 알았다.
// 문제에서는 화폐 종류를 money라는 배열에 제공하고 있었지만,
// 나는 문제의 예시인 1, 2, 5원만 가지고 n원을 거슬러주는 방식을 구한 것이었다.

// 다만 그렇다고 한들 DP를 이용했으면 쉽게 풀 수 있었지만,
// 나는 DP를 적용하는 것을 화폐 종류 단위가 아닌 거스름돈의 값을 기준으로 하였기 때문에 더 어렵게 접근하였다.

// 내가 한 방식

// 1원, 2원, 3원, ..., n-2원, n-1원, n원 순으로 DP 수행

// 좋은 방식
// 화폐의 종류가 [1, 2, 3] 이라고 할 때,
// 1. 1원짜리 화폐를 이용해 거슬러줄 수 있는 거스름돈인 1원부터 n원까지 1로 초기화 (경우의 수가 1로만 이루어진 1개)
// 2. 1에서 구한 1원짜리 화폐만으로 거슬러주는 경우에서 2원짜리 화폐를 이용해 거슬러 주는 경우 추가 (d[n] = d[n] + d[n-2])
// 3. 2에서 구한 1원짜리와 2원짜리 화폐만으로 거슬러주는 경우에서 3원짜리 화폐를 이용해 거슬러 주는 경우 추가 (d[n] = d[n] + d[n-3])
