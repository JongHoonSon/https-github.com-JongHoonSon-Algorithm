function solution(a) {
  var answer = 0;

  let lastIndex = a.length - 1;

  // i번째 지점의 왼쪽의 최솟값을 저장할 배열
  let minLeft = new Array(a);

  minLeft[0] = a[0];

  for (let i = 1; i < a.length; i++) {
    minLeft[i] = Math.min(minLeft[i - 1], a[i]);
  }

  console.log(minLeft);

  // i번째 지점의 오른쪽의 최솟값을 저장할 배열
  let minRight = new Array(a);

  minRight[lastIndex] = a[lastIndex];

  for (let i = lastIndex - 1; i >= 0; i--) {
    minRight[i] = Math.min(minRight[i + 1], a[i]);
  }

  console.log(minRight);

  let cnt = 0;

  // 모든 풍선에 대해 반복
  for (let i = 0; i < a.length; i++) {
    // i번째 풍선의 왼쪽, 오른쪽에 i번째 풍선보다 작은 값이 있을 경우(밑에서 설명한 1번의 경우), 넘어감
    if (minLeft[i] < a[i] && minRight[i] < a[i]) {
      continue;
    }

    // 위의 조건문에 걸리지 않음
    // => 미에서 설명한 2,3,4번의 경우 중 하나
    cnt++;
  }

  answer = cnt;

  return answer;
}

// 문제 풀이 접근 방식

// 이 문제에서는 두 풍선 중에서 값이 작은 풍선이 살아남는다.

// 따라서 i번째 풍선이 끝까지 살아남기 위해서는
// i번째 풍선의 왼쪽의 풍선 중에서 가장 작은 값과
// i번째 풍선의 오른쪽 풍선 중에서 가장 작은 값보다
// i번째 풍선의 값이 더 작으면, 모든 풍선 중에서 가장 작은 풍선이 되므로
// i번째 풍선이 끝까지 살아남을 수 있다.

// i번째 풍선의 크기는 총 4가지 경우로 나뉜다.

// 1. i번째 풍선의 왼쪽 풍선의 최솟값보다 크고, 오른쪽 풍선의 최솟값보다 큰 경우
// 2. i번째 풍선의 왼쪽 풍선의 최솟값보다 작고, 오른쪽 풍선의 최솟값보다 큰 경우
// 3. i번째 풍선의 왼쪽 풍선의 최솟값보다 크고, 오른쪽 풍선의 최솟값보다 작은 경우
// 4. i번째 풍선의 왼쪽 풍선의 최솟값보다 작고, 오른쪽 풍선의 최솟값보다 작은 경우

// 여기서 4번의 경우 모든 풍선 중에서 가장 작은 풍선이 되므로, 무조건 끝까지 살아남을 수 있다.

// 여기서, 문제의 조건으로 인해 두 풍선 중에 값이 더 작은 풍선을 최대 1번 터뜨릴 수 있으므로,
// 2번, 3번의 경우 역시, 본인의 한쪽편에서 최솟값인 풍선이 끝까지 살아남은 후,
// 본인과 비교할 때 그 최솟값인 풍선을 기회를 써서 터뜨리면 되므로, 끝까지 살아남을 수 있다.

// 하지만 1번의 경우에는 어떤 수를 써도 양쪽에 자신보다 값이 작은 풍선이 1개씩 존재하므로,
// 끝까지 살아남을 방법이 없다.

// 따라서 모든 풍선의 좌우 최솟값을 저장하고,
// 각 풍선이 확인하면서 1번에 해당하는 풍선을 제외한 나머지 풍선의 수를 세면 된다.
