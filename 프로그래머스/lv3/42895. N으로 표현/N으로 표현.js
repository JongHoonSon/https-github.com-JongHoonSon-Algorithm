function solution(N, number) {
  // 모든 요소를 Set으로 변경한 크기 9 짜리의 배열 memo 생성
  // memo의 i번째 인덱스에는 N을 i번 사용해서 만들 수 있는 연산의 결과 값이 저장되어 있음
  let memo = new Array(9).fill(0).map((el) => new Set());

  console.log("memo : ", memo);

  // 만약 구해야하는 number와 주어진 N이 같다면, N 1개로 number를 만들 수 있으므로 1 출력
  if (N === number) {
    return 1;
  } else {
    // memo의 1번 인덱스부터 8번 인덱스까지 사용
    // (문제 조건에서 연산을 최소 1번부터 최대 8번까지 진행하기 때문)
    for (let i = 1; i < 9; i++) {
      // N을 i번 사용한 연산의 결과를 저장하는 memo[i]에
      // i개의 N으로 이루어진 수를 넣음
      // ex) N을 3번 사용한 연산인 memo[3]에 333을 넣음
      memo[i].add(Number(String(N).repeat(i)));

      // memo의 i번째 인덱스의 값을 채우는 과정
      // memo[i]는 memo[j]와 memo[i-j]의 연산으로 이루어짐
      // ex) memo[4]는 memo[1]과 memo[3] 사이의 연산
      //               memo[2]과 memo[2] 사이의 연산
      //               memo[3]과 memo[1] 사이의 연산 의 조합임

      for (let j = 1; j < i; j++) {
        // N을 j번 써서 만들 수 있는 연산의 결과 값을 하나씩 사용
        // 이를 first라 부름
        for (let first of memo[j]) {
          // N을 i-j번 써서 만들 수 있는 연산의 결과 값을 하나씩 사용
          // 이를 second라 부름
          for (let second of memo[i - j]) {
            // first와 second의 사칙연산의 결과를 memo의 i번째 인덱스에 저장
            memo[i].add(first + second);
            memo[i].add(first - second);
            memo[i].add(first * second);
            memo[i].add(first / second);
          }
        }
      }

      // memo[i]에 대한 계산이 끝난 후,
      // 만약 memo[i] 안에 number가 들어있다면
      // 사용한 N의 횟수인 i를 리턴함
      if (memo[i].has(number)) return i;
    }

    // memo를 8번 인덱스까지 모두 채웠지만, 그 와중에 number인 수를 찾지 못했다면
    // -1 리턴
    return -1;
  }
}

// 후기
// 따져야할 사항이 굉장히 많은 문제임에도 불구하고 문제 설명이 부족해 어려웠다.
// (5를 뒤에 추가하는 경우가 언제 가능한지의 정보가 아예 없음)
// ex) 55 + 5는 되지만
//      5 + 55는 되는지의 여부

// 나는 처음에 중간에 5가 붙는 경우도 가능하다고 생각해서 문제를 푸는 접근 방식 자체를
// 구글링해서 찾은 정석인 방식보다 다르게 접근하였다.

// 각 연산과정에 5를 붙이는 경우도 고려해서 풀었는데, 이 경우는 정답으로 처리받을 수 없어
// 약 10개의 테스트케이스 중 6개 정도는 실패했다.

// 따라서 구글링해서 문제를 해결한 방식을 찾아보았고, 해당 방식대로 문제를 풀어 제출하니 성공하였다.

// 문제 풀이 접근 방식
// 내가 기존에 풀었던 방식은 물론 문제 조건에 대해 착각하기는 했으나, 접근 방식 자체가 결코 좋은 방식은 아니었다.
// 계산과정에서 사용될 것 같은 수의 최댓값인 max(단순 예상으로 number*N으로 함)를 memo라는 배열의 크기로 설정하고,
// DP라는 함수의 매개변수로 이전 단계에서 계산된 값 i와, N이 사용된 횟수 cnt를 계속 전달받으며
// DP(N, 1)이 DP(NN, 2), DP(N+N, 2), ..., DP(N/N, 2)를 재귀호출 하는 방식으로 사용하였고,
// 또 각 cnt가 2번인 DP가 3번인 DP를 재귀호출하는 방식으로 사용하였다.
// 각 DP에서는 이전 단계에서의 계산한 값인 i를 인덱스로 하는 memo[i]에 cnt 값을 저장하였다.
// 종료조건은 이전 단계에서 계산한 결과 i가 max보다 크거나, cnt의 횟수가 9일 때 종료하게 하였다.

// 즉, 특정 수를 만들 때의 N의 갯수를
// 1부터 max까지의 수에 대해 memo에 저장했다는 것이다.
// N이 1일 때 구할 수 있는 수
// -> N이 2일 때 구할 수 있는 수 (N이 1일 떄 구할 수 있는 수에 사칙연산)
// 이 방식대로 해서 memo[number]의 값이 존재하는지 확인하는 식으로 하였다.

// 이 방법의 문제는 배열의 인덱스의 기준을 수로 정하였기 때문에, 배열의 크기를 예상하기 힘들다는 것이다.

// 그래서 구글링을 통해 위에서 푼 방식대로, N이 사용된 횟수를 배열의 인덱스로 갖는 방식으로 풀었더니, 좀 더 확실하게 접근할 수 있었다.

// 앞으로 문제를 푸는 과정에서 확신이 들지 않으면 좀 더 생각해보는 여유를 가져봐야겠다.
