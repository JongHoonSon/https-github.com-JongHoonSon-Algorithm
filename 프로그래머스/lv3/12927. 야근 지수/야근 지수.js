function solution(n, works) {
  var answer = 0;

  // works를 오름차순으로 정렬
  works.sort((a, b) => b - a);

  // 남은 양이 많은 작업(0번째 작업)부터 남은 양이 적은 작업(n-1번째 작업)까지
  // 각 작업의 오른쪽 작업과의 차이를 저장할 배열
  // (쉽게 말해, 본인보다 적은 작업 중에서 양이 가장 많은 작업과의 작업량 차이)
  let worksGap = new Array(works.length);

  // i번째 작업의 작업량 차이 = (i번째 작업) - (i-1번째 작업)
  for (let i = 0; i < works.length - 1; i++) {
    worksGap[i] = works[i] - works[i + 1];
  }

  // 마지막 작업은 제일 작은 작업이므로 차이를 0으로 둠
  worksGap[worksGap.length - 1] = 0;

  // 일단 반복 (종료는 반복문 안에서 이뤄짐)

  // 종료 조건 2가지
  // 1. n의 값이 0이 될 때 (= 시간을 다 써서 더 이상 야근을 수행할 수 없을 때)
  // 2. works의 모든 값이 0일 때 (= 모든 작업을 다 수행했을 때)
  out: while (true) {
    // i : 각 작업
    for (let i = 0; i < worksGap.length; i++) {
      // i번째 작업의 차이가 0이 아니라면
      if (worksGap[i] !== 0) {
        // i번째 작업의 차이가 0이 될때까지 반복함
        while (worksGap[i] !== 0) {
          // j : 0번째부터 i번째 작업
          for (let j = 0; j <= i; j++) {
            // 각 작업을 1번씩 처리함
            works[j] = works[j] - 1;

            // 남은 시간을 1시간 줄임
            n = n - 1;

            // 남은 시간이 0이면 (= 더이상 야근을 수행할 수 없다면), 반복문 종료, 종료 조건1
            if (n === 0) {
              break out;
            }
          }

          // i번째 작업의 차이를 1 줄임
          worksGap[i] = worksGap[i] - 1;
        }
      }
    }

    // 위 과정에서 break out; 에 걸리지 않았다는 것은
    // 남은 시간이 0보다 큰데, 모든 작업의 차이가 똑같아졌다는 뜻 (ex) works가 [1, 1, 1, 1, 1]이 된 경우 등 )
    // 따라서 모든 작업에 대해 한 번씩 작업을 수행함

    while (true) {
      // 모든 작업이 종료되었는지 체크할 변수
      // (처음에 주어진 야근 예정 시간(n)이 3인데, 남은 총 작업의 양은 2일 수 있음 (예제3번))
      let allIsZero = true;

      // 모든 작업에 대해 반복
      for (let i = 0; i < works.length; i++) {
        // 만약 i번째 작업의 남은 양이 0이 아니라면 (= 작업을 할 게 남았다면)
        if (works[i] !== 0) {
          // 모든 작업이 종료된게 아니므로, allIsZero 를 false로 변경함
          allIsZero = false;

          // 해당 작업의 남은 양을 -1함
          works[i] = works[i] - 1;

          // 남은 시간을 -1함
          n = n - 1;

          // 남은 시간이 0이면 (= 더이상 야근을 수행할 수 없다면), 반복문 종료, 종료 조건1
          if (n === 0) {
            break out;
          }
        }
      }

      // 모든 작업을 수행했다면 반복문 종료, 종료 조건2
      if (allIsZero) {
        break out;
      }
    }
  }

  let result = 0;

  // 야근 후의 남은 작업에 대해 야근 지수 계산
  for (let i = 0; i < works.length; i++) {
    result = result + works[i] ** 2;
  }

  answer = result;

  return answer;
}

// 문제 설명

// 야근 지수는 각 작업의 남은 양에 제곱한 값의 합이다.
// 예를 들면 3개의 작업이 남았고, 남은 작업의 양이 [3, 2, 2] 라면
// 야근 지수는 3^2 + 2^2 + 2^2 = 9 + 4 + 4 = 17 이다.

// 각 작업의 남은 양이 works 배열에 주어졌을 때,
// n시간 동안 작업을 한 후에 야근 지수가 가장 적게 남을 수 있는 경우의
// 야근 지수를 출력하면 된다.

// 문제 풀이 접근 방식

// 야근 지수를 적게 만들기 위해서는 남은 양이 가장 많은 작업을 우선적으로 처리하면 된다.
// 따라서 각 작업의 남은 양이 담긴 works를 내림차순으로 정렬한 후,
// 각 작업 간의 차이를 기록하는 worksGap 배열에
// 맨 앞의 작업(=가장 남은 양이 많은 작업)부터 시작해서 오른쪽 작업과의 차이를 기록한다.
// 마지막 작업은 0을 기록하면 된다.

// 예를 들어 각 작업의 남은 양을 기록한 works 배열의 값이 [10, 5, 3, 2, 1] 이었다면
// worksGap의 값은 [5, 2, 1, 1, 0]이 된다.

// 이렇게 worksGap을 만드는 이유는 works 상의 맨 앞의 작업(=가장 남은 양이 많은 작업)을
// 오른쪽 작업(=두번째로 남은 양이 많은 작업)과 같은 값이 될 때까지 작업을 수행하기 위해서이다.
// 이를 첫번째 작업부터 마지막-1 작업까지 반복하면 works 배열은 아래와 같이 변경된다.

// [10, 5, 3, 2, 1]

// [5, 5, 3, 2, 1]

// [3, 3, 3, 2, 1]

// [2, 2, 2, 2, 1]

// [1, 1, 1, 1, 1]

// 이렇게 가장 적은 양이 남은 작업의 값만큼 일을 처리했으면

// 이제는 모든 작업에 대해 한번씩 작업을 수행하면 된다.

// 모든 과정에서 일을 처리할 때 마다, 주어진 n의 값을 1씩 감소시키고,
// 만약 n이 0이 되었다면, (=더 이상 야근을 진행할 수 없다면) 가장 바깥의 반복문을 빠져나오고,

// 마지막으로 works의 정보로 야근지수를 계산한 후 answer에 넣어 return하면 문제를 해결할 수 있다.
