function solution(clothes) {
  var answer = 0;

  // 각 종류의 옷의 갯수를 저장할 Map
  const clothMap = new Map();

  // clothes 배열에 들어있는 옷의 type을 확인
  clothes.forEach(([name, type]) => {
    // 만약 clothMap에 이미 type이 있으면
    if (clothMap.has(type)) {
      // 해당 type의 값(해당 종류의 옷의 갯수)을 + 1 시킴
      clothMap.set(type, clothMap.get(type) + 1);

      // 만약 clothMap에 해당 type이 존재하지 않으면
    } else {
      // 해당 종류로 처음 들어온 옷이므로 1로 저장함
      clothMap.set(type, 1);
    }
  });

  let totalCnt = 1;

  // 각 종류의 옷의 갯수를 cnt로 받음
  for (let cnt of clothMap.values()) {
    // totalCnt에 옷을 입는 모든 경우의 수를 계산함
    totalCnt = totalCnt * (cnt + 1);
  }

  // 모든 옷을 안입는 경우를 제외함
  answer = totalCnt - 1;

  return answer;
}

// 후기

// 어떤 방식으로 풀어야할지, BT를 이용해서 모든 경우의 수를 찾아야하는지 등을 고민하다가
// 도무지 접근 방식이 떠오르지 않아 구글링해서 방식을 찾았다.
// 생각보다 풀이 방식이 쉬웠고, 단지 풀이 과정에서 Map 또는 Object를 이용해서
// Hash를 이용하는 문제였다.

// 문제 풀이 접근 방식

// 각 종류의 옷은 안입거나 최대 1개씩만 입을 수 있다는 것만 감안하면,
// 각 종류의 옷을 입을 수 있는 경우의 수는
// 0개를 입는 경우, 1개의 경우의 수가 존재하고
// 1개를 입는 경우, 해당 종류의 옷의 갯수만큼의 경우의 수가 존재한다.

// 이를 모든 종류의 옷에 적용하면 된다.
// 각 종류의 옷을 입을 경우의 수는 해당 종류의 옷의 갯수 + 1이고,

// 각 종류의 옷의 갯수 + 1을 모두 곱하면
// 옷을 입는 모든 경우의 수를 만들 수 있다.

// ex) 옷의 종류가 A, B, C가 있고,
// A는 2개, B와 C는 1개씩 있다고 할 때, 아래와 같은 경우의 수가 존재한다.

// A는 안입거나, A-1을 입거나, A-2를 입거나  => 3가지 경우
// B는 안입거나, B을 입거나  => 2가지 경우
// C는 안입거나, C을 입거나  => 2가지 경우

// 위 경우를 모두 곱하면 옷을 입는 모든 경우의 수를 만들 수 있으며,
// 추가적으로 최소 1개의 옷은 입어야하므로 모든 종류의 옷을 입지 않은 경우를 빼준다.

// 따라서 답은 (각 종류의 옷의 갯수 + 1)을 모두 곱하고, -1을 한 값이다.
