function solution(s) {
  var answer = [];

  // sArr은 입력으로 주어진 문자열 s를 배열로 변경한 것
  let sArr = s.split("");

  let arr = [];
  let set = [];

  // 문자열에서 각 집합을 구분하여 2차원 배열 형태로 넣기
  // 구조 : 배열 arr 안에 각 집합의 배열이 들어있음

  // sArr의 원소에 대해 반복
  for (let i = 0; i < sArr.length; i++) {
    // 만약 괄호 열기가 나오면,
    // 집합의 원소가 나오기 시작하거나
    // 문자열의 첫 시작 부분이라는 뜻이므로
    if (sArr[i] === "{") {
      // 집합의 원소를 담을 set을 초기화함
      set = [];

      // 만약 괄호 닫기가 나오면,
      // 집합의 원소가 다 나왔거나
      // 문자열의 맨 끝 부분이라는 뜻이므로
    } else if (sArr[i] === "}") {
      // 만약 집합의 원소가 set에 담겼다면
      if (set.length > 0) {
        // 해당 집합의 원소를 arr에 넣음
        arr.push(
          set
            .join("")
            .split(",")
            .map((v) => +v)
        );
      }
    } else {
      // 괄호 열기와 괄호 닫기가 아닌 경우 (집합의 원소 또는 , 등)
      // 집합 set에 해당 문자를 넣음
      set.push(sArr[i]);
    }
  }

  // arr에는 각 집합이 배열 형태로 들어있다.
  // arr의 원소를 배열의 길이 순으로 정렬함
  arr.sort((a, b) => a.length - b.length);

  // 집합의 길이가 증가하면서 새로 생긴 원소를 answer에 저장한다.
  // (새로 생긴 원소 = answer에 들어간적이 없는 원소)
  for (let i = 0; i < arr.length; i++) {
    for (let j = 0; j < arr[i].length; j++) {
      if (!answer.includes(arr[i][j])) {
        answer.push(arr[i][j]);
      }
    }
  }

  return answer;
}

// 문제 풀이 접근 방식

// 먼저 문제에서 요구하는 튜플을 구하기 위해서는
// 각 집합의 길이가 짧은 것부터 나열한 뒤에
// 집합의 길이가 증가할 때 새로 추가된 원소의 순서대로 튜플에 저장하면 된다.

// 예를 들어, 집합이 다음과 같은 순서로 주어졌다고 가정해보면

// {1}
// {1, 7}
// {1, 7, 2}
// {1, 7, 2, 5}

// 튜플은 [1, 7, 2, 5] 가 된다.

// 단, 문제에서는 집합이 길이가 짧은 것부터 순서대로 주어지지 않았기 때문에
// 직접 집합을 길이 순서대로 정렬해야한다.

// 따라서 먼저 각 집합을 구분하여 배열에 담고,
// 배열 형태로 나타낸 각 집합을 길이가 짧은 것부터 정렬한 뒤,
// 길이가 증가하면서 새로 추가된 원소를 순서대로 저장하면 튜플을 구할 수 있다.
