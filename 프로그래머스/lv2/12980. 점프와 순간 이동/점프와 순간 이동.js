function solution(n) {
  var ans = 0;

  // 점프 횟수를 저장할 변수
  let cnt = 0;

  // n이 0이 될 때까지 반복
  while (n !== 0) {
    // n이 2로 나누어 떨어지면
    if (n % 2 === 0) {
      // 2로 나눔 (문제에서 얘기하는 순간이동)
      n = n / 2;

      // n이 2로 나누어 떨어지지 않으면
    } else {
      // 점프 1회 수행
      cnt++;
      n = n - 1;
    }
  }

  // 0이 될 때까지의 사용한 점프 횟수를 출력하면 된다.
  ans = cnt;

  return ans;
}

// 후기

// 문제 설명을 읽는 순간, 기존에 많이 풀어보았던
// 영희가 동생을 찾기 위해 현재 위치 x2로 순간이동 또는 -1 / +1로 이동하는 문제가 떠올랐다.
// 따라서 깊은 고민 없이 memoization 기법을 이용하여 문제를 풀고자 하였다.
// memoization 기법을 이용해 문제는 풀어냈지만 시간초과 오류가 발생하였다.

// 바로 문제에서 주어진 n의 범위가 10억개이기 때문에, 크기가 10억인 배열을 만드는데만 시간초과가 발생하기 때문이었다.
// 즉, 애초부터 가능한 접근 방식이 아니었다.
// 결국 좀 더 심플하게 문제를 풀 수 있는 방법에 대해 고민해보았지만, 풀지 못하였고, 구글링을 통해 답을 찾았다.
// 문제는 생각보다 매우매우매우 쉬운 문제였다.
// 레벨2인 문제에서 잘 나오지 않는 수준의 개념으로 풀려고 했던게 실패 요인이었던 것 같다.

// 문제 풀이 접근 방식

// 문제에서는 0에서 N으로 갈 때의 필요한 가장 적은 점프거리를 요구하고 있다. (점프거리에 대한 설명은 문제 설명 참고)
// 나는 따라서 0에서 N으로 증가하면서 구했지만, 문제 풀이를 찾아보니 N에서 거꾸로 0으로 내려오는 경우가 있었다.
// 2배의 위치로 점프할 수 있으므로, N을 역으로 2로 나누는 과정을 반복하면서
// 만약 2로 나눈 나머지가 2로 나눠 떨어지지 않으면, -1을 하고, 이어서 진행한다.
// ex) 550을 2로 나눠 225가 나온 경우
// 해당 경우에서 1을 빼서 224인 짝수를 만들고 다시 2로 나눈다.

// 즉, 위 과정을 앞쪽인 0부터 진행하였다면 224에서 +1을 하고 550으로 점프했다는 얘기이다.
// 문제에서 이미 도착 지점이 주어졌기 때문에 가능한 방법이었다.
// 최종적으로 N을 0까지 만드는 데 사용하는 점프횟수를 출력하면 된다.
